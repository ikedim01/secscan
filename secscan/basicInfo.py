# AUTOGENERATED! DO NOT EDIT! File to edit: 05_basicInfo.ipynb (unless otherwise specified).

__all__ = ['defaultBasicInfoDir', 'defaultTextLimit', 'getSecFormLinkList', 'getSecFormCikList', 'getTextAfterTag',
           'get99Texts', 'getSecFormInfo', 'companyNameAndCikPat', 'periodPat', 'periodDatePatStr', 'periodDatePat',
           'acceptedPat', 'acceptedDateTimePat', 'itemsPat', 'itemFormTypes', 'startExhibitPat']

# Cell

import os
import re

from secscan import utils,dailyList

defaultBasicInfoDir = os.path.join(utils.stockDataRoot,'basicInfo')
defaultTextLimit = 1000

# Cell

def getSecFormLinkList(indexSoup,accessNo) :
    """
    Returns
        sublinkList, completeTextLink
    where sublinkList is:
        [(name, description, type, sublink), ... ]
    Prints a warning message if the complete text link is missing.
    """
    linkList = []
    completeLink = None
    for row in indexSoup.find_all('tr') :
        entries = row.find_all('td')
        if len(entries)>1 and row.a is not None :
            #print utils.getCombSoupText(entries[3])
            if utils.getCombSoupText(entries[0]).isdigit() and len(entries)>=4 :
                linkList.append((utils.getCombSoupText(row.a),
                                 utils.getCombSoupText(entries[1]),
                                 utils.getCombSoupText(entries[3]),
                                 row.a.get('href','')))
            elif utils.getCombSoupText(entries[1]).lower().startswith('complete') :
                completeLink = row.a.get('href','')
    if not linkList :
        print('*** missing link list in ',utils.secIndexUrl(accessNo,True))
    if not completeLink :
        print('*** missing complete text link in',utils.secIndexUrl(accessNo,True))
    return linkList, completeLink

companyNameAndCikPat = re.compile(r'(.*)\s*\(.*cik[\s:]*(\d+)',re.IGNORECASE)
def getSecFormCikList(indexSoup,accessNo) :
    """
    Returns list of CIKs for the form: [cik, ... ]
    """
    cikList = []
    for companyNameTag in indexSoup.find_all('span','companyName') :
        companyNameStr = utils.getCombSoupText(companyNameTag)
        m = companyNameAndCikPat.match(companyNameStr)
        if m is None :
            print('missing company name or CIK in',companyNameStr)
            print(utils.secIndexUrl(accessNo,True))
        elif m.group(2) not in cikList :
            cikList.append(m.group(2))
    if len(cikList) == 0 :
        print('no company names in',utils.secIndexUrl(accessNo,True))
    return cikList

def getTextAfterTag(resDict, resKey, top, firstTagPat,
                    firstTagName='div', firstTagClass='infoHead',
                    nextTagName='div', nextTagClass='info',
                    missingMessage=None, strListHeader=None) :
    """
    Looks for a sequence of two HTML elements specified by name and class,
    with the text of the first element matching a given regular expression.
    If found, stores the text of the second element in resDict[resKey].
    If not found and missingMessage is not None, prints it.
    """
    for firstTag in top.find_all(firstTagName,firstTagClass) :
        if firstTagPat.match(utils.getCombSoupText(firstTag)) :
            nextTag = firstTag.find_next_sibling(nextTagName,nextTagClass)
            if nextTag is not None :
                if isinstance(strListHeader,str) :
                    resDict[resKey] = [str(elem).strip() for elem in nextTag
                                       if str(elem).strip().lower().startswith(strListHeader)]
                else :
                    resDict[resKey] = utils.getCombSoupText(nextTag)
                return
    if missingMessage is not None :
        print(missingMessage)

periodPat = re.compile('period',re.IGNORECASE)
periodDatePatStr = r'\d\d\d\d-\d\d-\d\d'
periodDatePat = re.compile(periodDatePatStr)
acceptedPat = re.compile('accepted',re.IGNORECASE)
acceptedDateTimePat = re.compile('('+periodDatePatStr+r')[ t](\d\d:\d\d:\d\d)',
                                 re.IGNORECASE)
itemsPat = re.compile('items',re.IGNORECASE)

itemFormTypes = re.compile('8-K',re.IGNORECASE)

startExhibitPat = re.compile(r'.{1,100}exhibit\s*\d+(?:\.\d+)?\.?',re.IGNORECASE)
def get99Texts(info, textLimit=defaultTextLimit) :
    res = []
    for _,_,linkType,url in info.get('links',[]) :
        if (linkType.lower().startswith('ex-99')
            and (url.lower().endswith('.htm') or url.lower().endswith('.html'))) :
            urlText = utils.downloadSecUrl(url, toFormat='souptext')
            m = startExhibitPat.match(urlText)
            if m :
                urlText = urlText[m.end():]
            res.append(urlText[:textLimit].strip())
        else :
            res.append('')
    return res

def getSecFormInfo(accessNo, formType=None, get99=False, textLimit=defaultTextLimit) :
    """
    Parses some basic information from the index URL of a form with the given accession number.
    Returns a dict {
        'links' : [(name, description, type, sublink), ... ],
        'complete' : completeTextLink,
        'ciks' : [cik, ... ],
    }
    For some forms, additional fields may be parsed:
        'period' : 'YYYY-MM-DD',
        'acceptDate' : 'YYYY-MM-DD',
        'acceptTime' : 'HH:MM:SS',
        'items' : [title, ... ],
    """
    indexSoup = utils.downloadSecUrl(accessNo, toFormat='soup')
    indexFullUrl = utils.secIndexUrl(accessNo,True)
    links, completeLink = getSecFormLinkList(indexSoup,accessNo)
    res = {
        'links': links,
        'complete': completeLink,
        'ciks' : getSecFormCikList(indexSoup,accessNo),
    }
    if get99 :
        res['text99'] = get99Texts(res, textLimit=textLimit)
    if links :
        if formType is None :
            formType = links[0][2]
        elif formType != links[0][2] :
            print('formType mismatch', formType, links[0])
    missingPeriodMessage = None
    if formType is None or not dailyList.noPeriodFormTypes.match(formType) :
        missingPeriodMessage = 'missing period in ' + indexFullUrl
    getTextAfterTag(res, 'period', indexSoup, periodPat,
                    missingMessage=missingPeriodMessage)
    if 'period' in res and not periodDatePat.match(res['period']) :
        print('malformed period',res['period'],'in',indexFullUrl)
        del res['period']
    getTextAfterTag(res, 'acceptDateTime', indexSoup, acceptedPat,
                    missingMessage='missing accepted in ' + indexFullUrl)
    if 'acceptDateTime' in res :
        m = acceptedDateTimePat.match(res['acceptDateTime'])
        if not m :
            print('malformed accept date/time',res['acceptDateTime'])
            print('in',indexFullUrl)
        else :
            res['acceptDate'] = m.group(1)
            res['acceptTime'] = m.group(2)
        del res['acceptDateTime']
    missingItemsMessage = None
    if formType is None or itemFormTypes.match(formType) :
        missingItemsMessage = 'missing items in ' + indexFullUrl
    getTextAfterTag(res,'items', indexSoup, itemsPat, strListHeader='item',
                    missingMessage=missingItemsMessage)
    return res