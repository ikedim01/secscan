# AUTOGENERATED! DO NOT EDIT! File to edit: 07_scrape13F.ipynb (unless otherwise specified).

__all__ = ['default13FDir', 'findChildEndingWith', 'findChildSeries', 'getRowInfo', 'parse13FHoldings', 'scraper13F',
           'callOptPat', 'putOptPat', 'condenseHoldings', 'get13FAmendmentType', 'cikConsolidatedHoldings',
           'getPeriodAndNextQStartEnd', 'getMatrixFor', 'saveConvMatrixFor', 'qStartEnds', 'qPeriods']

# Cell

import collections
import itertools
import numpy as np
import os
import re

from secscan import utils, dailyList, basicInfo, infoScraper

default13FDir = os.path.join(utils.stockDataRoot,'scraped13F')

# Cell

def findChildEndingWith(el,tagEnd) :
    "Finds first child of an XML element with tag ending in tagEnd (case insensitive)."
    tagEnd = tagEnd.lower()
    for child in el :
        if child.tag.lower().endswith(tagEnd) :
            return child
    return None

def findChildSeries(el,tagEnds) :
    "Finds a nested series of children by tag using findChildEndingWith"
    for tagEnd in tagEnds :
        el = findChildEndingWith(el,tagEnd)
    return el

callOptPat = re.compile(r'call\s*opt',re.IGNORECASE)
putOptPat = re.compile(r'put\s*opt',re.IGNORECASE)

def getRowInfo(row) :
    """
    Returns information for a row in a 13F table in the form:
        (cusip, name, value, title, count, putCall)
    where the field values are as given in the table,
    except putCall is 'CALL', 'PUT', or ''.
    """
    cusip = findChildEndingWith(row,'cusip').text.upper().strip()
    name = findChildEndingWith(row,'issuer').text.strip()
    value = findChildEndingWith(row,'value').text.strip()
    title = findChildEndingWith(row,'titleOfClass').text.upper().strip()
    shrsOrPrnEl = findChildEndingWith(row,'shrsOrPrnAmt')
    count = findChildEndingWith(shrsOrPrnEl,'sshPrnamt').text.strip()
    #countType = findChildEndingWith(shrsOrPrnEl,'sshPrnamtType').text.upper()
    putCallEl = findChildEndingWith(row,'putCall')
    if putCallEl is None :
        putCallEl = findChildEndingWith(shrsOrPrnEl,'putCall')
        #if putCallEl is not None :
        #    print('found putcall in shrsOrPrn')
    if putCallEl is not None :
        putCall = putCallEl.text.upper().strip()
    elif callOptPat.search(name) or title.startswith('CALL') or title=='CAL' :
        putCall = 'CALL'
    elif putOptPat.search(name) or title.startswith('PUT') :
        putCall = 'PUT'
    else :
        putCall = ''
    return (cusip, name, value, title, count, putCall)

def parse13FHoldings(accNo, formType=None) :
    """
    Parses a 13F filing, returning the result in the form:
    {
        'period': 'YYYY-MM-DD',
        'acceptDate': 'YYYY-MM-DD',
        'acceptTime': 'HH:MM:SS',
        'cik' : 'DDDDDDDDDD',
        'holdings': [(cusip, name, value, title, count, putCall), ... ]
    }
    where the field values are as given in the table,
    except putCall is 'CALL', 'PUT', or ''.
    """
    info = basicInfo.getSecFormInfo(accNo, formType)
    xmlUrls = [l[-1] for l in info['links'] if l[0].lower().endswith('xml')]
    if len(xmlUrls) == 1 :
        xmlSummTab = utils.downloadSecUrl(xmlUrls[0],toFormat='xml')
        tot = int(findChildSeries(xmlSummTab,['formdata','summarypage','tableentrytotal']).text.strip())
        if tot == 0 :
            print('*** zero total, table not present')
        else :
            print('*** nonzero total, but table not present')
        holdings = []
    else :
        xmlTab = utils.downloadSecUrl(xmlUrls[-1],toFormat='xml')
        tabRows = [tabRow for tabRow in xmlTab
                   if tabRow.tag.lower().endswith('infotable')]
        if len(xmlTab) != len(tabRows) :
            print('*** #rows mismatch',len(xmlTab),'all children',len(tabRows),'table rows')
        if len(tabRows) == 0 :
            print('*** no holdings in table')
        holdings = [getRowInfo(tabRow) for tabRow in tabRows]
    if len(info['ciks']) != 1 :
        print('*** unexpected number of CIKs!=1',info['ciks'])
    return {'period': info['period'],
            'acceptDate': info['acceptDate'],
            'acceptTime': info['acceptTime'],
            'cik': info['ciks'][0],
            'holdings': holdings}

class scraper13F(infoScraper.scraperBase) :
    def __init__(self, infoDir=default13FDir, startD=None, endD=None, fSuff='m.pkl', **pickle_kwargs) :
        super().__init__(infoDir, '13F-HR', startD=startD, endD=endD, fSuff=fSuff, **pickle_kwargs)
    def scrapeInfo(self, accNo, formType=None) :
        return parse13FHoldings(accNo, formType), None

# Cell

def condenseHoldings(holdings, minFrac=0.0, maxFrac=1.0, pctFormat=False, includeName=False, cusipNames={}) :
    """
    Converts a list of of stock and option holdings as parsed from the 13F:
        [(cusip, name, value, title, count, putCall), ... ]
    that may have multiple entries per stock into a condensed list that omits
    options and only has one combined entry per stock:
        [(cusip, val, frac) ... ]
    sorted in descending order by value, and restricted to stocks with fraction
    of total portfolio in [minFrac..maxFrac]
    """
    if includeName :
        cusipToName = dict((cusip,name)
                           for cusip, name, value, shType, nShares, putCall in holdings)
    holdings = sorted((cusip, float(value))
                      for cusip, name, value, shType, nShares, putCall in holdings
                      if putCall=='')
    holdings = [(cusip, sum(val for _,val in it))
                for cusip,it in itertools.groupby(holdings, key=lambda x : x[0])]
    holdings.sort(key = lambda x : x[1], reverse=True)
    tot = sum(val for _,val in holdings)
    res = []
    for cusip,val in holdings :
        frac = val/tot if tot>0.0 else 0.0
        if frac < minFrac or maxFrac < frac :
            break
        fracOut = f'{frac:.2%}' if pctFormat else frac
        if includeName :
            res.append((cusip, cusipNames.get(cusip,cusipToName[cusip]), val, fracOut))
        else :
            res.append((cusip, val, fracOut))
    return res

def get13FAmendmentType(accNo, formType=None) :
    """
    Gets the amendment type for a 13F-HR/A filing - may be RESTATEMENT or NEW HOLDINGS.
    This turned out to be unreliable (often missing or wrong), so I don't use it to get
    the combined holdings for an investor. Instead I just look at the number of holdings
    in an amendment compared to the previous filing, and treat it as a restatement
    if the new number of holdings is more than half the old number.
    """
    info = basicInfo.getSecFormInfo(accNo, formType)
    xmlUrls = [l[-1] for l in info['links'] if l[0].lower().endswith('xml')]
    xmlSummTab = utils.downloadSecUrl(xmlUrls[0],toFormat='xml')
    coverPage = findChildSeries(xmlSummTab,['formdata','coverpage'])
    isAmendment = findChildEndingWith(coverPage,'isamendment')
    if isAmendment is None or isAmendment.text.strip().lower() not in ['true','yes'] :
        return None
    return findChildSeries(coverPage,['amendmentinfo','amendmenttype']).text.strip()

class cikConsolidatedHoldings(object) :
    def __init__(self, scraped13F, period, minFrac=0.0, maxFrac=1.0) :
        """
        Consolidate holdings for each CIK based on all filings with a given period.
        Restrict to stocks only (no options) with fraction of total portfolio in [minFrac..maxFrac].
        Sets self.cikToPosList: cik -> [(cusip, val, frac) ... ]
        and  self.investorsPerStock: cusip -> nInvestors
        """
        #
        # Map cik to a list [(dateStr, accNo, holdingsList) ... ]
        # of all 13F filings from that cik with the given period.
        cikTo13Fs = collections.defaultdict(list)
        count = 0
        for dStr, accNoToInfo in scraped13F.infoMap.items() :
            for accNo, info in accNoToInfo.items() :
                if info == 'ERROR' :
                    print('ERR',accNo)
                elif info['period'] == period :
                    cikTo13Fs[info['cik'].lstrip('0')].append((dStr, accNo, info['holdings']))
                    count += 1
        print('period',period,'- total of',len(cikTo13Fs),'ciks,',count,'13F filings')
        #
        # Get a consolidated list of positions for each cik. For ciks with multiple filings
        # this may involve combining amended filings. Since the filed amendment type is
        # unreliable I use a simple rule of thumb - if the amendment has more than half
        # as many positions as the previous filing I assume it's a restatement, otherwise
        # I add its positions to the previous filing.
        self.cikToPosList = {}
        for cik, cik13FList in cikTo13Fs.items() :
            cik13FList.sort()  # sort by day and then by accession number
            i = 0
            j = 1
            while j < len(cik13FList) :
                if len(cik13FList[j][2]) > len(cik13FList[i][2])//2 :
                    # relatively many new positions - assume filing j is a restatement
                    i = j
                j += 1
            if j != 1 :
                print('CIK',cik,i,'-',j,[(dStr,accNo,len(holdings))
                                         for dStr,accNo,holdings in cik13FList])
            combHoldings = cik13FList[i][2]
            while i+1 < j :
                i += 1
                combHoldings = combHoldings + cik13FList[i][2]
            self.cikToPosList[cik] = condenseHoldings(combHoldings,
                                                      minFrac=minFrac, maxFrac=maxFrac)
        # generate a count of investors per stock:
        self.investorsPerStock = collections.Counter()
        for posList in self.cikToPosList.values() :
            self.investorsPerStock.update(cusip for cusip,_,_ in posList)
    def getHoldingsMatrix(self, minInvestorsPerStock=3, minStocksPerInvestor=1, dtype=np.float64) :
        """
        Calculates a combined matrix of investor holdings.
        Returns ciks, cusips, mat
        where mat is a matrix of shape (len(ciks), len(cusips))
        in which each row has the fractions held by the corresponding cik in each cusip.
        """
        print('requiring ', minInvestorsPerStock, 'investors per stock,',
              minStocksPerInvestor, 'stocks per investor')
        cusipsToKeep = set(cusip for cusip,nInvestors in self.investorsPerStock.items()
                           if nInvestors >= minInvestorsPerStock)
        ciksToKeepPosLists = {}
        for cik,posList in self.cikToPosList.items() :
            keepPosList = [tup for tup in posList if tup[0] in cusipsToKeep]
            if len(keepPosList) >= minStocksPerInvestor :
                ciksToKeepPosLists[cik] = keepPosList
        print(len(ciksToKeepPosLists), 'investors,', len(cusipsToKeep), 'stocks')
        cusips = sorted(cusipsToKeep)
        cusipToCol = dict((cusip,i) for i,cusip in enumerate(cusips))
        ciks = sorted(ciksToKeepPosLists.keys())
        cikToRow = dict((cik,i) for i,cik in enumerate(ciks))
        res = np.zeros((len(ciks), len(cusips)), dtype=dtype)
        count = 0
        for cik,posList in ciksToKeepPosLists.items() :
            for cusip,_,frac in posList :
                res[cikToRow[cik], cusipToCol[cusip]] = frac
                count += 1
        print('total of',count,'positions')
        return ciks, cikToRow, cusips, cusipToCol, res

qStartEnds = ['0101','0401','0701','1001','0101']
qPeriods = ['-03-31','-06-30','-09-30','-12-31']
def getPeriodAndNextQStartEnd(y, qNo) :
    """
    Returns the 13F period date for a given year and quarter number (this is the
    last day in the quarter), along with the start and end dateStrs for the next
    quarter (this is the date range when the 13Fs for this year should be filed).
    Quarters are numbered 1-4.
    """
    nextY = y+1 if qNo==4 else y
    nextQNo = 1 if qNo==4 else qNo+1
    return (str(y)+qPeriods[qNo-1],
            {'startD' : str(nextY) + qStartEnds[nextQNo-1],
             'endD' : str(nextY+1 if nextQNo==4 else nextY) + qStartEnds[nextQNo]})

def getMatrixFor(y, qNo, minFrac=0.0, maxFrac=1.0, minInvestorsPerStock=3, minStocksPerInvestor=1) :
    period, nextQStartEnd = getPeriodAndNextQStartEnd(y,qNo)
    cikConsHoldings = cikConsolidatedHoldings(scraper13F(**nextQStartEnd), period,
                                              minFrac=minFrac, maxFrac=maxFrac)
    return cikConsHoldings.getHoldingsMatrix(minInvestorsPerStock=minInvestorsPerStock,
                                             minStocksPerInvestor=minStocksPerInvestor)

def saveConvMatrixFor(y, qNo, minFrac=0.12, maxFrac=0.4, minInvestorsPerStock=2, minStocksPerInvestor=1) :
    m = getMatrixFor(y, qNo, minFrac=minFrac, maxFrac=maxFrac,
                     minInvestorsPerStock=minInvestorsPerStock, minStocksPerInvestor=minStocksPerInvestor)
    print(m[-1].shape)
    print(os.path.join(utils.stockDataRoot,f'Conv{y}Q{qNo}.pkl'))
    utils.pickSave(os.path.join(utils.stockDataRoot,f'Conv{y}Q{qNo}.pkl'), m,
                   fix_imports=True, protocol=2)