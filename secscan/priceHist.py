# AUTOGENERATED! DO NOT EDIT! File to edit: 14_priceHist.ipynb (unless otherwise specified).

__all__ = ['USExchanges', 'getHistFStuff', 'getDayMap', 'getCombDayMap', 'getCombDayMapsForRange',
           'getDayMapWithLookback', 'getCombDayMapsForRangeWithLookback', 'getCleanedPriceData', 'getForwardReturns',
           'getClosestReturn']

# Cell

import datetime
import numpy as np
import os
import pandas as pd

from secscan import utils

USExchanges = ['AMEX','NASDAQ','NYSE','OTCBB']

# Cell

def getHistFStuff(exch,dateStr) :
    """
    Returns (fName, fDir, fPath) containing the CSV file of historical prices
    for the given exchange and date.
    """
    fName = exch+'_'+dateStr+'.csv'
    histFDir = os.path.join(utils.stockPriceRoot,fName[:len(exch)+5])
    histFPath = os.path.join(histFDir,fName)
    return fName,histFDir,histFPath

# Cell

def getDayMap(dateStr, exch, symCol='Symbol', priceCol='Close') :
    """
    Parse the CSV file for a single day and exchange,
    returning a dict:<stock symbol> -> <value>
    """
    fPath = getHistFStuff(exch,dateStr)[2]
    if not os.path.exists(fPath) :
        return {}
    df = pd.read_csv(fPath, na_filter=False)
    dayMap = {}
    for sym,val in zip(df[symCol],df[priceCol]) :
        if isinstance(sym,str) :
            dayMap[sym] = val
        else :
            print(dateStr,exch,'non-string symbol',repr(sym))
    return dayMap

# Cell

@utils.delegates(getDayMap)
def getCombDayMap(dateStr, exchs=USExchanges, checkDups=True, **kwargs) :
    """
    Combines the day maps for a list of exchanges, optionally checking for symbols
    duplicated between exchanges.
    """
    combDayMap = {}
    for exch in exchs :
        m = getDayMap(dateStr,exch,**kwargs)
        if checkDups :
            dupKeys = (set(m.keys()) & combDayMap.keys())
            if len(dupKeys) > 0 :
                print('duplicated keys:',exch,dateStr,sorted(dupKeys)[:10])
        combDayMap.update(m)
    return combDayMap

# Cell

@utils.delegates(getCombDayMap)
def getCombDayMapsForRange(d1, d2, **kwargs) :
    """
    Get all the combined day maps from d1 (inclusive) to d2 (exclusive).
    Returns a dict:dateStr -> {<stock symbol> -> <value>}
    """
    combDayMapsForRange = {}
    for d in utils.dateStrsBetween(d1, d2) :
        combDayMapsForRange[d] = getCombDayMap(d, **kwargs)
    return combDayMapsForRange

def getDayMapWithLookback(combDayMapsForRange, forD, lookback) :
    """
    Get the day map for a given day, looking back a given number of days -
    i.e. uses the value from a previous day if it's not present in the given day.
    """
    if lookback == 0 :
        return combDayMapsForRange[forD]
    d1 = utils.toDate(forD) + datetime.timedelta(-lookback)
    d2 = utils.toDate(forD) + datetime.timedelta(1)
    dayMap = {}
    for d in utils.dateStrsBetween(d1, d2) :
        dayMap.update(combDayMapsForRange[d])
    return dayMap

@utils.delegates(getCombDayMap)
def getCombDayMapsForRangeWithLookback(d1, d2, lookback=7, **kwargs) :
    """
    Get all the combined day maps from d1 (inclusive) to d2 (exclusive), with lookback.
    Returns a dict:dateStr -> {<stock symbol> -> <value>}
    Skips weekend dates.
    """
    combDayMapsForRange = getCombDayMapsForRange(utils.toDate(d1)+datetime.timedelta(-lookback),
                                                 d2, **kwargs)
    res = {}
    for d in utils.dateStrsBetween(d1, d2) :
        if utils.isWeekend(d) :
            continue
        res[d] = getDayMapWithLookback(combDayMapsForRange, d, lookback)
    return res

@utils.delegates(getCombDayMapsForRangeWithLookback)
def getCleanedPriceData(d1, d2, minPrice=None, **kwargs) :
    """
    """
    dayMaps = getCombDayMapsForRangeWithLookback(d1, d2, **kwargs)
    dateList = sorted(dayMaps.keys())
    symsPresentAllDays = sorted(set.intersection(*(set(dayMap.keys())
                                                   for dayMap in dayMaps.values())))
    if minPrice is not None :
        symsToRemove = set()
        for dayMap in dayMaps.values() :
            for sym,val in dayMap.items() :
                if val < minPrice :
                    symsToRemove.add(sym)
        symsPresentAllDays = [sym for sym in symsPresentAllDays
                              if sym not in symsToRemove]
    priceMat = np.zeros((len(symsPresentAllDays),len(dateList)))
    for dateNo,d in enumerate(dateList) :
        dayMap = dayMaps[d]
        for symNo,sym in enumerate(symsPresentAllDays) :
            priceMat[symNo,dateNo] = dayMap[sym]
    print(len(symsPresentAllDays),'symbols',len(dateList),'dates')
    return (symsPresentAllDays, dateList, priceMat)

@utils.delegates(getCleanedPriceData)
def getForwardReturns(d1, d2, d3, weekdaysForward=20, **kwargs) :
    """
    """
    syms, dateStrs, priceMat = getCleanedPriceData(d1,d3,**kwargs)
    dateStrs = [d for d in dateStrs if d<d2]
    returnMat = np.zeros((len(syms), len(dateStrs)))
    for j in range(len(dateStrs)) :
        returnMat[:,j] = priceMat[:,j+weekdaysForward]/priceMat[:,j]
    return syms,dateStrs,returnMat

def getClosestReturn(sym, syms, dateStrs, returnMat) :
    """
    """
    rowNo = syms.index(sym)
    diffs = ((returnMat - returnMat[rowNo])**2).sum(axis=1)
    symsAndDiffs = list(zip(syms,diffs))
    symsAndDiffs.sort(key=lambda x : x[1])
    return symsAndDiffs