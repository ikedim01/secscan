# AUTOGENERATED! DO NOT EDIT! File to edit: 14_priceHist.ipynb (unless otherwise specified).

__all__ = ['USExchanges', 'getHistFStuff', 'getDayMap', 'getCombDayMap', 'getCombDayMapWithLookback',
           'getCombDayMapsForRangeWithLookback', 'getCleanedPriceData', 'getForwardReturns', 'getClosestReturn',
           'getTextPriceDataset', 'textScraperL']

# Cell

import collections
import datetime
import numpy as np
import os
import pandas as pd

from secscan import utils,tickerMap,scrape8K,scrape6K

USExchanges = ['AMEX','NASDAQ','NYSE','OTCBB']

# Cell

def getHistFStuff(exch,dateStr) :
    """
    Returns (fName, fDir, fPath) containing the CSV file of historical prices
    for the given exchange and date.
    """
    fName = exch+'_'+dateStr+'.csv'
    histFDir = os.path.join(utils.stockPriceRoot,fName[:len(exch)+5])
    histFPath = os.path.join(histFDir,fName)
    return fName,histFDir,histFPath

# Cell

def getDayMap(dateStr, exch, symCol='Symbol', priceCol='Close') :
    """
    Parse the CSV file for a single day and exchange.
    Returns a dict:<stock symbol> -> <value>
    """
    fPath = getHistFStuff(exch,dateStr)[2]
    if not os.path.exists(fPath) :
        return {}
    df = pd.read_csv(fPath, na_filter=False)
    dayMap = {}
    for sym,val in zip(df[symCol],df[priceCol]) :
        if isinstance(sym,str) :
            dayMap[sym] = val
        else :
            print(dateStr,exch,'non-string symbol',repr(sym))
    return dayMap

# Cell

@utils.delegates(getDayMap)
def getCombDayMap(dateStr, exchs=USExchanges, checkDups=True, **kwargs) :
    """
    Combines the day maps for a list of exchanges, optionally checking for symbols
    duplicated between exchanges.
    Returns a dict:<stock symbol> -> <value>
    """
    combDayMap = {}
    for exch in exchs :
        m = getDayMap(dateStr,exch,**kwargs)
        if checkDups :
            dupKeys = (set(m.keys()) & combDayMap.keys())
            if len(dupKeys) > 0 :
                print('duplicated keys:',exch,dateStr,sorted(dupKeys)[:10])
        combDayMap.update(m)
    return combDayMap

# Cell

@utils.delegates(getCombDayMap)
def getCombDayMapWithLookback(forD, dayMapCache=None, lookback=7, **kwargs) :
    """
    Get the day map for a given day, looking back a given number of days -
    i.e. if a stock doesn't trade on a particular day, looks back the specified
    number of days to find the most recent trade.

    Returns a dict:<stock symbol> -> <value>
    """
    d1 = utils.toDate(forD) + datetime.timedelta(-lookback)
    d2 = utils.toDate(forD) + datetime.timedelta(1)
    dayMap = {}
    if dayMapCache is None :
        dayMapCache = {}
    for d in utils.dateStrsBetween(d1, d2) :
        if d not in dayMapCache :
            dayMapCache[d] = getCombDayMap(d, **kwargs)
        dayMap.update(dayMapCache[d])
    return dayMap

@utils.delegates(getCombDayMapWithLookback)
def getCombDayMapsForRangeWithLookback(d1, d2, **kwargs) :
    """
    Get all the combined day maps from d1 (inclusive) to d2 (exclusive), with lookback.

    Returns a dict:dateStr -> {<stock symbol> -> <value>}
    Skips weekend dates in the returned dict.
    """
    dayMapCache = {}
    res = {}
    for d in utils.dateStrsBetween(d1, d2, excludeWeekends=True) :
        res[d] = getCombDayMapWithLookback(d, dayMapCache=dayMapCache, **kwargs)
    return res

# Cell

@utils.delegates(getCombDayMapsForRangeWithLookback)
def getCleanedPriceData(d1, d2, minPrice=None, restrictToNames=False, **kwargs) :
    """
    Constructs a price dataset for direct indexing tests.

    First gets all the combined day maps from d1 to d2, with specified lookback,
    and skipping weekend days.

    Then, cuts down to stocks that have values for all the specified days.

    If minPrice is not None, also cuts down to stocks with value > minPrice on all days.

    If restrictToNames is True, also cuts down to stocks present in the SEC ticker list.

    Returns a tuple (syms, symNames, dateStrs, priceMat), where:
    syms is a sorted list of ticker symbols
    symNames is a list of corresponding names from the SEC ticker list ('' if not present)
    dateStrs is a list of date strings in the format '20240624'
    priceMat is a matrix of values with len(syms) rows and len(dateStrs) columns
    """
    dayMaps = getCombDayMapsForRangeWithLookback(d1, d2, **kwargs)
    dateStrs = sorted(dayMaps.keys())
    symsPresentAllDays = sorted(set.intersection(*(set(dayMap.keys())
                                                   for dayMap in dayMaps.values())))
    symsToRemove = set()
    if minPrice is not None :
        for dayMap in dayMaps.values() :
            for sym,val in dayMap.items() :
                if val < minPrice :
                    symsToRemove.add(sym)
    tickerNames = tickerMap.getSecTickerDict(field2='name')
    if restrictToNames :
        for sym in symsPresentAllDays :
            if sym not in tickerNames :
                symsToRemove.add(sym)
    if len(symsToRemove) > 0 :
        symsPresentAllDays = [sym for sym in symsPresentAllDays
                              if sym not in symsToRemove]
    priceMat = np.zeros((len(symsPresentAllDays), len(dateStrs)))
    for dateNo,d in enumerate(dateStrs) :
        dayMap = dayMaps[d]
        for symNo,sym in enumerate(symsPresentAllDays) :
            priceMat[symNo,dateNo] = dayMap[sym]
    symNames = [
        f' ({tickerNames[sym]})' if sym in tickerNames else ''
        for sym in symsPresentAllDays
    ]
    print(len(symsPresentAllDays),'symbols',len(dateStrs),'dates')
    return (symsPresentAllDays, symNames, dateStrs, priceMat)

@utils.delegates(getCleanedPriceData)
def getForwardReturns(d1, d2, d3, weekdaysForward=20, **kwargs) :
    """
    """
    syms, symNames, dateStrs, priceMat = getCleanedPriceData(d1,d3,**kwargs)
    dateStrs = [d for d in dateStrs if d<d2]
    returnMat = np.zeros((len(syms), len(dateStrs)))
    for j in range(len(dateStrs)) :
        returnMat[:,j] = priceMat[:,j+weekdaysForward]/priceMat[:,j]
    return (syms, symNames, dateStrs, returnMat)

def getClosestReturn(sym, syms, symNames, dateStrs, returnMat) :
    """
    """
    rowNo = syms.index(sym)
    diffs = ((returnMat - returnMat[rowNo])**2).sum(axis=1)
    symsAndDiffs = list((sym+symName,diff) for sym,symName,diff in zip(syms,symNames,diffs))
    symsAndDiffs.sort(key=lambda x : x[1])
    return symsAndDiffs

# Cell

textScraperL = [
    {'class': scrape8K.scraper8K, 'fClass': '8-K',
        'infoTextKeys': ['explanatoryNote','itemTexts','text99']},
    {'class': scrape6K.scraper6K, 'fClass': '6-K',
        'infoTextKeys': ['mainText','text99']},
]

@utils.delegates(getCombDayMapWithLookback)
def getTextPriceDataset(d1, d2, d3, d4, minPrice=None, **kwargs) :
    """
    Constructs a text/price dataset for text-based prediction tests.

    First gets day maps from d2 and d3, with specified lookback.

    Then, cuts down to stocks that have values for both days.

    If minPrice is not None, also cuts down to stocks with value > minPrice on both days.

    Returns a tuple (syms, symNames, dateStrs, priceMat), where:
    syms is a sorted list of ticker symbols
    symNames is a list of corresponding names from the SEC ticker list ('' if not present)
    dateStrs is a list of date strings in the format '20240624'
    priceMat is a matrix of values with len(syms) rows and len(dateStrs) columns
    """
    dm3 = getCombDayMapWithLookback(d3, **kwargs)
    dm4 = getCombDayMapWithLookback(d4, **kwargs)
    symsWithPrices = sorted(set(dm3.keys()).intersection(dm4.keys()))
    print(len(symsWithPrices),'stock symbols found')
    if minPrice is not None :
        print('restricting to price >=',minPrice,end=' ... ')
        symsWithPrices = [sym for sym in symsWithPrices
                          if dm3[sym]>=minPrice and dm4[sym]>=minPrice]
        print('now',len(symsWithPrices),'stocks')
    cikToTicker = tickerMap.getCikToFirstTickerMap()
    tickerToCik = dict((ticker,cik) for cik,ticker in cikToTicker.items())
    print('restricting to CIKs',end=' ... ')
    symsWithPrices = [sym for sym in symsWithPrices if sym in tickerToCik]
    print('now',len(symsWithPrices),'stocks')
    for s in textScraperL :
        print('loading',s['fClass'],end=' ... ')
        s['scraper'] = s['class'](startD=d1, endD=d2)
        s['scraper'].printCounts(verbose=False)
    print('getting CIK texts',end=' ... ')
    symsWithPricesAsSet = set(symsWithPrices)
    symTexts = collections.defaultdict(list)
    for d in utils.dateStrsBetween(d1, d2, excludeWeekends=True) :
        for s in textScraperL :
            for accNo,info in s['scraper'].infoMap[d].items() :
                if info == 'ERROR' :
                    continue
                ciks = [cik.lstrip('0') for cik in info.get('ciks',[])]
                ciks = [cik for cik in ciks
                        if cikToTicker.get(cik,'-') in symsWithPricesAsSet]
                if len(ciks)==0 :
                    continue
                for cik in ciks :
                    symTexts[cikToTicker[cik]].append('TEXT')
#                 if any(findAllSS(andL, info, ['cikNames']+s['infoTextKeys'])
#                         for andL in searchREs) :
#                     res.append((dStrIso, s['fClass'], accNo, info))
    print(len(symTexts),'stocks with CIK text found')