# AUTOGENERATED! DO NOT EDIT! File to edit: 11_scrape13D.ipynb (unless otherwise specified).

__all__ = ['default13DDir', 'scraper13D', 'get13GDDatesForQ', 'getCombNSSForQ', 'oddballScreen', 'nssDelegatedFuncs',
           'defaultNSSArgs']

# Cell

import collections
import itertools
import numpy as np
import os
from pathlib import Path
import re

from secscan import utils, dailyList, basicInfo, infoScraper, scrape13F, scrape13G

default13DDir = os.path.join(utils.stockDataRoot,'scraped13D')

# Cell

class scraper13D(scrape13G.scraper13G) :
    @utils.delegates(scrape13G.scraper13G.__init__)
    def __init__(self, infoDir=default13DDir, **kwargs) :
        super().init_for_13D(infoDir, **kwargs)

# Cell

def get13GDDatesForQ(y, qNo) :
    _,kwargs = scrape13F.getPeriodAndNextQStartEnd(y, qNo)
    kwargs['startD'] = str(int(kwargs['startD'][:4])-3) + kwargs['startD'][4:]
    return kwargs

nssDelegatedFuncs = (scrape13F.filter13FHoldings, scrape13F.holdingsMapToMatrix, scrape13G.calcBonusMap,
                     utils.pickSave)
@utils.delegates(*nssDelegatedFuncs)
def getCombNSSForQ(y, qNo, ratingScale=100.0, maxRating=20.0,
                   cusipNameFilter=lambda cusip,name : name is not None,
                   include13F=True, include13G=True, include13D=True,
                   outsInfoFName='', outDir='ratings', **kwargs) :
    """
    Calculates a matrix of investor ratings for a quarter, based on all 13F filings filed
    during the succeeding quarter, combined with 13G and 13D filings from the previous
    three years through the succeeding quarter.

    Returns (ratings, cusipMap, cik13GDSortedPosMap, all13FHoldingsMap), where:
        ratings = {'Y': mat, 'ciks': ciks, 'cusips': cusips,
                    'cusipinfo': [], 'deletedcusips': deletedCusips}
            where mat is a matrix of shape (len(ciks), len(cusips)) in which each row
            has the fractions held by the corresponding cik in each cusip.
        cusipMap[cusip] = cusipName
            for all cusips with any investor position found
        cik13GDSortedPosMap[cik] = [(cusip, (eventDate, accNo, pct, fType))]
                                 sorted in descending order by pct
        all13FHoldingsMap[cik] = [(cusip, val, frac) ... ]
                                 sorted in descending order by value

    If cusipNameFilter is specified, this should be a function that gets two arguments cusip and
    name, where name will be None if no name was found in either the SEC 13F CUSIP name index or
    in the CUSIP-CIK correspondence from 13D and 13G forms, and returns True for cusips to keep.

    Uses scrape13F.filter13FHoldings and scrape13F.holdingsMapToMatrix to filter the returned matrix.
    Uses scrape13G.calcBonusMap to calculate rating bonuses for 13G/D positions.

    If outsInfoName is not None, saves the results in four pickled files for the specified quarter in outDir:
        outDir/f'{outsInfoFName}{y}Q{qNo}' + ('sInfo','cusipMap','hold13GD','hold13F') + 'pkl'
    Uses utils.pickSave to save the pickled files.
    """
    utils.checkDelegated(*nssDelegatedFuncs,**kwargs)
    allCusipCounter = collections.Counter()
    all13FHoldingsMap = {}
    cikNames = utils.loadPklFromDir(dailyList.defaultDLDir, 'cikNames.pkl', {})
    cikNames = dict((cik,name) for cik,(name,dStr) in cikNames.items())
    cusipNames = utils.pickLoad(os.path.join(utils.stockDataRoot,'13FLists',f'{y}Q{qNo}secCusipMap.pkl'))
    if include13G or include13D :
        dates = get13GDDatesForQ(y,qNo)
        cik13GDPosMap = scrape13G.updateCik13GDPos(
                        scrape13G.scraper13G(**dates) if include13G else None,
                        scraper13D(**dates) if include13D else None,
                        cusipNames=cusipNames, cikNames=cikNames, includeTickers=True)
        cikBonusMaps = [utils.callDelegated(scrape13G.calcBonusMap, kwargs, cik13GDPosMap, allCusipCounter)]
        cik13GDSortedPosMap = dict((cik,sorted(((cusip,pos) for cusip,pos in posMap.items()),
                                        # sort positions largest first, then by name
                                        key=lambda x : (-x[1][2], cusipNames.get(x[0],'CUSIP-'+x[0]).lower())))
                                   for cik,posMap in cik13GDPosMap.items())
    else :
        cikBonusMaps = []
        cik13GDSortedPosMap = {}
    res = scrape13F.getNSSForQ(y, qNo, allCusipCounter=allCusipCounter,
                               cusipFilter=lambda cusip : cusipNameFilter(cusip,cusipNames.get(cusip)),
                               extraHoldingsMaps=cikBonusMaps, include13F=include13F,
                               all13FHoldingsMap=all13FHoldingsMap,
                               **kwargs)
    mat, ciks, cusips = res
    mat *= ratingScale
    mat = np.minimum(mat,maxRating)
    res = (
        {'Y': mat, 'ciks': ciks, 'cusips': cusips, 'cusipinfo': [],
         'deletedcusips': set(cusip for cusip in cusips
                              if 'DELETED' in cusipNames.get(cusip,''))},
        dict((cusip, name) for cusip,name in cusipNames.items() if cusip in allCusipCounter),
        cik13GDSortedPosMap,
        all13FHoldingsMap,
    )
    if outsInfoFName is not None :
        if outDir is None :
            outDir = Path(utils.stockDataRoot)
        else :
            outDir = Path(utils.stockDataRoot)/outDir
        if not outDir.exists() :
            outDir.mkdir()
        for ob,fNameEnding in zip(res,('sInfo.pkl','cusipMap.pkl','hold13GD.pkl','hold13F.pkl')) :
            utils.callDelegated(utils.pickSave, kwargs,
                                outDir/f'{outsInfoFName}{y}Q{qNo}{fNameEnding}', ob)
    return res

defaultNSSArgs = dict(
    # arguments to scrape13F.filter13FHoldings:
    minFrac=0.01, maxFrac=1.0, minTopNFrac=0.4, minTopN=10, minAUM=None,
    # arguments to scrape13F.holdingsMapToMatrix:
    minMatStocksPerInv=3,
    # arguments to scrape13G.calcBonusMap:
    bonuses = {'13G':[(10.0,0.1), (5.0,0.05)],
               '13D':[(10.0,0.2), (5.0,0.1)],},
    max13GDCount=50,
    # arguments to utils.pickSave:
    fix_imports=True, protocol=2,
)

def oddballScreen(yNo, qNo) :
    """
    Screens for stocks that only one investor reports holding.
    These will mostly be mistakes, so I try to remove the mistakes using cusipNameFilter.
    """
    res = getCombNSSForQ(yNo, qNo,
                            maxAllInvsPerStock=1, minMatStocksPerInv=2, max13GDCount=None,
                            cusipNameFilter = lambda cusip,name :
                                                name is not None and 'DELETED' not in name,
                            outsInfoFName=None)
    return [res[1][cusip] for cusip in res[0]['cusips']]